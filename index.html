<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading Experiment - AOM</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Papers data -->
    <script src="papers-data.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, doc, getDoc, setDoc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Your web app's Firebase configuration
        const firebaseConfig = {
        apiKey: "AIzaSyClsZXLxKOXjUtB5loTfz0__GpJ8AQYEas",
        authDomain: "aom-paper-understanding.firebaseapp.com",
        projectId: "aom-paper-understanding",
        storageBucket: "aom-paper-understanding.firebasestorage.app",
        messagingSenderId: "668607386746",
        appId: "1:668607386746:web:dc6711c596542fe1b217c3"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Make Firebase available globally
        window.firebaseDb = db;
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseDoc = doc;
        window.firebaseGetDoc = getDoc;
        window.firebaseSetDoc = setDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseServerTimestamp = serverTimestamp;
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Icons
        const SendIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="22" y1="2" x2="11" y2="13"></line>
                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const ClockIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        );

        const CheckIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
        );

        // Timer Component
        function Timer({ seconds, onComplete, isActive, phase, onTimeUpdate }) {
            const [timeLeft, setTimeLeft] = useState(seconds);

            useEffect(() => {
                setTimeLeft(seconds);
            }, [phase, seconds]);

            useEffect(() => {
                if (!isActive) return;

                const interval = setInterval(() => {
                    setTimeLeft(prev => {
                        const newTime = prev - 1;
                        if (onTimeUpdate) onTimeUpdate(newTime);
                        if (newTime <= 0) {
                            clearInterval(interval);
                            if (onComplete) onComplete();
                            return 0;
                        }
                        return newTime;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isActive, onComplete, onTimeUpdate]);

            const minutes = Math.floor(timeLeft / 60);
            const secs = timeLeft % 60;
            const isLowTime = timeLeft < 300;

            return (
                <div className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-mono text-lg ${
                    isLowTime ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700'
                }`}>
                    <ClockIcon />
                    <span>{String(minutes).padStart(2, '0')}:{String(secs).padStart(2, '0')}</span>
                </div>
            );
        }

        // Main Application Component
        function ReadingExperimentAOM() {
            // Experiment flow state
            const [phase, setPhase] = useState('setup'); // setup, reading-guide, reading, quiz-guide, quiz, review-guide, review, complete
            const [participantId, setParticipantId] = useState('');
            const [condition, setCondition] = useState('without_llm'); // without_llm, with_llm, with_llm_extended
            const [currentPaper, setCurrentPaper] = useState('mroz2018'); // Default paper
            const [sessionId] = useState(`session_${Date.now()}`);
            const [showFinishPopup, setShowFinishPopup] = useState(false);
            const [showAiUsagePopup, setShowAiUsagePopup] = useState(false); // AI usage check popup for without_llm
            const [usedAiDuringReading, setUsedAiDuringReading] = useState(null); // null, 'yes', 'no'
            const [noAiAgreed, setNoAiAgreed] = useState(false); // For without_llm condition warning
            const [isRedirecting, setIsRedirecting] = useState(false); // To skip beforeunload during redirect
            const [readingTimeLeft, setReadingTimeLeft] = useState(20 * 60); // Track remaining time

            // Reading phase state
            const [scrollPosition, setScrollPosition] = useState(0);
            const [currentSection, setCurrentSection] = useState('Introduction');
            const [selectedText, setSelectedText] = useState('');
            const [readingActive, setReadingActive] = useState(false);
            const [paperContent, setPaperContent] = useState('');

            // Focus state (for with_llm conditions)
            const [activeFocus, setActiveFocus] = useState('reading'); // 'reading' or 'chat'
            const [focusTimes, setFocusTimes] = useState({ reading: 0, chat: 0 });
            const focusStartTimeRef = useRef(Date.now());

            // Right panel tab state (for with_llm_extended)
            const [activeTab, setActiveTab] = useState(null); // 'infographics', 'video', 'audio', 'simplified', 'chat' or null for initial state

            // Resource state for extended condition
            const [resourceContent, setResourceContent] = useState({
                infographics: null,
                video: null,
                audio: null,
                audioType: null,
                simplified: null
            });

            // Resource usage tracking for extended condition
            const tabStartTimeRef = useRef(Date.now());
            const [tabUsageTimes, setTabUsageTimes] = useState({
                infographics: 0,
                video: 0,
                audio: 0,
                simplified: 0,
                chat: 0,
                quiz: 0
            });
            const audioRef = useRef(null);
            const videoRef = useRef(null);

            // Fake loading state for each tab (first time only)
            const [tabLoading, setTabLoading] = useState({
                infographics: false,
                video: false,
                audio: false,
                simplified: false,
                chat: false,
                quiz: false
            });
            const [tabLoaded, setTabLoaded] = useState({
                infographics: false,
                video: false,
                audio: false,
                simplified: false,
                chat: false,
                quiz: false
            });

            // Random tab order (shuffle content tabs, chat always at end)
            const [tabOrder] = useState(() => {
                const shuffleTabs = ['video', 'audio', 'infographics', 'quiz'];
                // Fisher-Yates shuffle
                for (let i = shuffleTabs.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffleTabs[i], shuffleTabs[j]] = [shuffleTabs[j], shuffleTabs[i]];
                }
                return [...shuffleTabs, 'chat'];
            });

            // Quiz phase state
            const [quizActive, setQuizActive] = useState(false);
            const [quizAnswers, setQuizAnswers] = useState({});

            // In-tab quiz state (for LLM-extended right panel quiz)
            const [inTabQuizAnswers, setInTabQuizAnswers] = useState({});
            const inTabQuizQuestions = [
                {
                    id: 'q1',
                    question: "According to the article, what is the primary focus of 'meeting science'?",
                    options: [
                        "A) Developing new technologies for virtual meetings",
                        "B) Studying what happens before, during, and after meetings",
                        "C) Reducing the total number of meetings in organizations",
                        "D) Training employees to take better meeting notes"
                    ],
                    correctAnswer: "B) Studying what happens before, during, and after meetings"
                },
                {
                    id: 'q2',
                    question: "Which of the following is identified in the paper as a critical 'after-meeting' action for ensuring meeting effectiveness?",
                    options: [
                        "A) Scheduling the next meeting immediately",
                        "B) Sending out meeting minutes and action items",
                        "C) Conducting a formal performance review",
                        "D) Providing refreshments to attendees"
                    ],
                    correctAnswer: "B) Sending out meeting minutes and action items"
                },
                {
                    id: 'q3',
                    question: "According to the research cited, bad meetings can negatively impact employee well-being beyond the workplace, affecting general life satisfaction.",
                    options: ["True", "False"],
                    correctAnswer: "True"
                },
                {
                    id: 'q4',
                    question: "The article suggests that the best way to improve organizational effectiveness is to eliminate all meetings entirely.",
                    options: ["True", "False"],
                    correctAnswer: "False"
                }
            ];

            // Review phase state
            const [reviewActive, setReviewActive] = useState(false);
            const [reviewData, setReviewData] = useState({
                rating: 0,
                strengths: '',
                weaknesses: '',
                suggestions: ''
            });

            // Chat state (for LLM conditions)
            const [messages, setMessages] = useState([]);
            const [inputMessage, setInputMessage] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [chatHistory, setChatHistory] = useState([]);
            const chatMessagesEndRef = useRef(null);
            const textareaRef = useRef(null);

            // Timer tracking
            const phaseStartTime = useRef(Date.now());
            const phaseTimers = useRef({
                reading: 0,
                quiz: 0,
                review: 0
            });

            // Logging state
            const [events, setEvents] = useState([]);
            const lastEventTime = useRef(Date.now());
            const unsavedEventsCount = useRef(0);
            const eventIdCounter = useRef(0);
            const isSaving = useRef(false);
            const pdfContainerRef = useRef(null);
            const scrollTimeoutRef = useRef(null);
            const lastActivityTimeRef = useRef(Date.now());
            const scrollStartTimeRef = useRef(null);
            const isScrollingRef = useRef(false);
            const sectionBeforeScrollRef = useRef('Introduction');

            // LLM typing tracking
            const isTypingRef = useRef(false);
            const typingTimeoutRef = useRef(null);
            const lastTypingActivityRef = useRef(Date.now());

            // Papers - use from shared data file
            const papers = typeof AVAILABLE_PAPERS !== 'undefined' ? AVAILABLE_PAPERS : [];

            // Quiz questions state
            const [quizQuestions, setQuizQuestions] = useState([
                {
                    id: 1,
                    question: "The 'science of meetings' is defined as the systematic study of what occurs during which phase(s) of the meeting process?",
                    options: ["Before, during, and after meetings, as well as their broader organizational context.", "Only the events that happen during the meeting itself.", "Primarily the design and preparation that happens before the meeting.", "Only the outcomes and follow-up actions after the meeting."],
                    correctAnswer: "Before, during, and after meetings, as well as their broader organizational context.",
                    type: "multiple_choice"
                },
                {
                    id: 2,
                    question: "Which of the following is identified as a best practice for the 'Before the meeting' phase?",
                    options: ["Circulating a written agenda in advance to all attendees.", "Intervening when communication patterns become dysfunctional.", "Sending out meeting minutes and action items.", "Actively encouraging everyone to participate."],
                    correctAnswer: "Circulating a written agenda in advance to all attendees.",
                    type: "multiple_choice"
                },
                {
                    id: 3,
                    question: "According to the article, satisfaction with meetings is a significant predictor of what broader employee attitude?",
                    options: ["Overall job satisfaction", "Trust in senior leadership", "Perceptions of organizational strategy", "Satisfaction with pay and promotion opportunities"],
                    correctAnswer: "Overall job satisfaction",
                    type: "multiple_choice"
                },
                {
                    id: 4,
                    question: "What is a critical action item for a meeting organizer to complete *after* a meeting has ended to ensure its effectiveness?",
                    options: ["Following an agenda to keep the meeting on track.", "Starting the meeting on time.", "Ensuring only people with relevant expertise are invited.", "Sending meeting minutes with an action plan to all relevant parties."],
                    correctAnswer: "Sending meeting minutes with an action plan to all relevant parties.",
                    type: "multiple_choice"
                },
            ]);

            // Section boundaries
            const [sectionBoundaries, setSectionBoundaries] = useState({
                'Abstract': { start: 0, end: 200 },
                'Introduction': { start: 200, end: 800 },
            });

            // Initialize from URL parameters (when coming from pre-study-survey)
            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const pid = urlParams.get('participantId');
                const cond = urlParams.get('condition');
                const paper = urlParams.get('paper');

                if (pid) setParticipantId(pid);
                if (cond) setCondition(cond);
                if (paper) setCurrentPaper(paper);
            }, []);

            // Expose current phase to window for feedback widget
            useEffect(() => {
                window.currentPhase = phase;
            }, [phase]);

            // Load resources for extended condition
            useEffect(() => {
                if (condition === 'with_llm_extended' && currentPaper) {
                    // Load infographics
                    const infographicPath = `papers_resources/${currentPaper}/infographic.png`;
                    fetch(infographicPath)
                        .then(res => {
                            if (res.ok) {
                                setResourceContent(prev => ({ ...prev, infographics: infographicPath }));
                            }
                        })
                        .catch(() => {});

                    // Load video
                    const videoPath = `papers_resources/${currentPaper}/video.mp4`;
                    fetch(videoPath)
                        .then(res => {
                            if (res.ok) {
                                setResourceContent(prev => ({ ...prev, video: videoPath }));
                            }
                        })
                        .catch(() => {});

                    // Load audio (try m4a first, then mp3)
                    const audioPathM4a = `papers_resources/${currentPaper}/audio.m4a`;
                    const audioPathMp3 = `papers_resources/${currentPaper}/audio.mp3`;
                    fetch(audioPathM4a)
                        .then(res => {
                            if (res.ok) {
                                setResourceContent(prev => ({ ...prev, audio: audioPathM4a, audioType: 'audio/mp4' }));
                            } else {
                                // Try mp3 as fallback
                                fetch(audioPathMp3)
                                    .then(res2 => {
                                        if (res2.ok) {
                                            setResourceContent(prev => ({ ...prev, audio: audioPathMp3, audioType: 'audio/mpeg' }));
                                        }
                                    })
                                    .catch(() => {});
                            }
                        })
                        .catch(() => {});

                    // Load simplified text
                    fetch(`papers_resources/${currentPaper}/simplified.html`)
                        .then(res => {
                            if (res.ok) return res.text();
                            return null;
                        })
                        .then(html => {
                            if (html) {
                                setResourceContent(prev => ({ ...prev, simplified: html }));
                            }
                        })
                        .catch(() => {});
                }
            }, [condition, currentPaper]);

            // Prevent back navigation during experiment
            useEffect(() => {
                window.history.pushState(null, '', window.location.href);

                const handlePopState = (e) => {
                    window.history.pushState(null, '', window.location.href);
                    const confirmBack = window.confirm(
                        'Are you sure you want to go back?\n\nAny unsaved progress will be lost.'
                    );
                    if (confirmBack) {
                        window.history.back();
                    }
                };

                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, []);

            // Auto-save on browser close
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (phase === 'reading' && unsavedEventsCount.current > 0) {
                        saveEventsToFirebase(events, false);
                    }
                    // Skip warning if we're intentionally redirecting
                    if ((phase === 'reading' || phase === 'quiz' || phase === 'review') && !isRedirecting) {
                        e.preventDefault();
                        e.returnValue = '';
                        return '';
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [phase, events, isRedirecting]);

            // Auto-scroll chat to bottom
            useEffect(() => {
                if (chatMessagesEndRef.current) {
                    chatMessagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [messages, isLoading]);

            // Create experiment document
            useEffect(() => {
                const createExperimentDoc = async () => {
                    if (phase === 'reading-guide' && participantId && sessionId && currentPaper) {
                        try {
                            if (window.firebaseDb) {
                                const experimentRef = window.firebaseDoc(
                                    window.firebaseDb,
                                    `users/${participantId}/experiments/${sessionId}`
                                );

                                await window.firebaseSetDoc(experimentRef, {
                                    participantId,
                                    sessionId,
                                    condition,
                                    paper: currentPaper,
                                    startedAt: window.firebaseServerTimestamp(),
                                    status: 'in_progress',
                                    createdAt: Date.now()
                                });

                                console.log('âœ… Experiment document created');
                            }
                        } catch (error) {
                            console.error('âŒ Failed to create experiment document:', error);
                        }
                    }
                };
                createExperimentDoc();
            }, [phase]);

            // Calculate section boundaries when entering reading phase
            useEffect(() => {
                if (phase === 'reading' && paperContent) {
                    setTimeout(() => {
                        const sections = document.querySelectorAll('[data-section]');
                        const container = document.getElementById('paper-content') || document.querySelector('.prose');

                        if (sections.length > 0 && container) {
                            const newBoundaries = {};
                            sections.forEach((section, index) => {
                                const sectionName = section.getAttribute('data-section');
                                const sectionTop = section.offsetTop;
                                let sectionEnd = index < sections.length - 1
                                    ? sections[index + 1].offsetTop
                                    : container.scrollHeight;

                                newBoundaries[sectionName] = { start: sectionTop, end: sectionEnd };
                            });
                            setSectionBoundaries(newBoundaries);
                            const firstSection = Object.keys(newBoundaries)[0];
                            if (firstSection) setCurrentSection(firstSection);
                        }
                    }, 500);
                }
            }, [phase, paperContent]);

            // Save events to Firebase
            const saveEventsToFirebase = async (eventsBatch, isPartialSave = true) => {
                if (isSaving.current) return false;
                isSaving.current = true;

                try {
                    if (!window.firebaseDb || !participantId || !sessionId) {
                        isSaving.current = false;
                        return false;
                    }

                    const experimentRef = window.firebaseDoc(
                        window.firebaseDb,
                        `users/${participantId}/experiments/${sessionId}`
                    );

                    const readingEvents = eventsBatch.filter(e =>
                        e.phase === 'reading' &&
                        (e.eventType === 'scroll_action' ||
                         e.eventType === 'focus_switch' ||
                         e.eventType === 'tab_switch' ||
                         e.eventType === 'llm_activity' ||
                         e.eventType === 'text_selection' ||
                         e.eventType === 'resource_tab_switch' ||
                         e.eventType === 'audio_play' ||
                         e.eventType === 'audio_pause' ||
                         e.eventType === 'audio_ended' ||
                         e.eventType === 'audio_seeked' ||
                         e.eventType === 'video_play' ||
                         e.eventType === 'video_pause' ||
                         e.eventType === 'video_ended' ||
                         e.eventType === 'video_seeked')
                    );

                    if (readingEvents.length === 0) {
                        isSaving.current = false;
                        return true;
                    }

                    const docSnap = await window.firebaseGetDoc(experimentRef);
                    const existingEvents = docSnap.exists() && docSnap.data().reading?.events
                        ? docSnap.data().reading.events
                        : [];

                    const existingKeys = new Set(
                        existingEvents.map(e => e.eventId || `${e.timestamp}_${e.eventType}`)
                    );
                    const newEventsOnly = readingEvents.filter(e => {
                        const key = e.eventId || `${e.timestamp}_${e.eventType}`;
                        return !existingKeys.has(key);
                    });

                    if (newEventsOnly.length === 0) {
                        unsavedEventsCount.current = 0;
                        isSaving.current = false;
                        return true;
                    }

                    const mergedEvents = [...existingEvents, ...newEventsOnly].sort((a, b) => a.timestamp - b.timestamp);

                    await window.firebaseUpdateDoc(experimentRef, {
                        'reading.events': mergedEvents,
                        'reading.lastAutoSave': window.firebaseServerTimestamp(),
                        'reading.totalEvents': mergedEvents.length
                    });

                    if (isPartialSave) {
                        console.log(`ðŸ’¾ Auto-saved ${newEventsOnly.length} events (total: ${mergedEvents.length})`);
                    }

                    unsavedEventsCount.current = 0;
                    isSaving.current = false;
                    return true;
                } catch (error) {
                    console.error('âŒ Auto-save failed:', error);
                    isSaving.current = false;
                    return false;
                }
            };

            // Log event
            const logEvent = async (eventType, additionalData = {}) => {
                const now = Date.now();
                const timeSinceLast = now - lastEventTime.current;

                eventIdCounter.current++;
                const eventId = `${sessionId}_${eventIdCounter.current}`;

                const event = {
                    eventId,
                    timestamp: now,
                    eventType,
                    phase,
                    timeSinceLast,
                    participantId,
                    sessionId,
                    condition,
                    paper: currentPaper,
                    ...additionalData
                };

                setEvents(prev => {
                    const newEvents = [...prev, event];

                    if (phase === 'reading') {
                        unsavedEventsCount.current++;
                        if (unsavedEventsCount.current >= 20) {
                            saveEventsToFirebase(newEvents, true);
                        }
                    }

                    return newEvents;
                });
                lastEventTime.current = now;

                // Local storage backup
                const storedEvents = JSON.parse(localStorage.getItem('experimentEvents_aom') || '[]');
                storedEvents.push(event);
                localStorage.setItem('experimentEvents_aom', JSON.stringify(storedEvents));
            };

            // Get current section based on viewport center
            const getCurrentSection = (scrollY, viewportHeight) => {
                const viewportCenter = scrollY + (viewportHeight / 2);

                for (const [section, bounds] of Object.entries(sectionBoundaries)) {
                    if (viewportCenter >= bounds.start && viewportCenter < bounds.end) {
                        return section;
                    }
                }
                return Object.keys(sectionBoundaries)[0] || 'Unknown';
            };

            // Tab switching with time tracking
            const switchFocus = (newFocus) => {
                if (newFocus === activeFocus) return;

                const now = Date.now();

                if (activeFocus === 'chat') {
                    const activityDuration = now - lastTypingActivityRef.current;
                    const classification = isTypingRef.current ? 'typing' : 'none-typing';

                    if (typingTimeoutRef.current) {
                        clearTimeout(typingTimeoutRef.current);
                        typingTimeoutRef.current = null;
                    }

                    logEvent('llm_activity', {
                        classification,
                        duration: activityDuration,
                        isFocusSwitch: true
                    });

                    isTypingRef.current = false;
                }

                if (newFocus === 'chat' && activeFocus === 'reading') {
                    const pauseDuration = now - lastActivityTimeRef.current;
                    let classification = pauseDuration > 5000 ? 'reading' : (pauseDuration > 2000 ? 'scanning' : 'scrolling');

                    logEvent('scroll_action', {
                        scrollY: pdfContainerRef.current?.scrollTop || 0,
                        sectionBeforeScroll: currentSection,
                        sectionAfterScroll: currentSection,
                        classification,
                        pauseDuration,
                        scrollDuration: 0,
                        isFocusSwitch: true,
                        timestamp: now
                    });

                    lastTypingActivityRef.current = now;
                    isTypingRef.current = false;
                }

                if (newFocus === 'reading' && activeFocus === 'chat') {
                    lastActivityTimeRef.current = now;
                }

                const elapsed = Date.now() - focusStartTimeRef.current;
                setFocusTimes(prev => ({
                    ...prev,
                    [activeFocus]: prev[activeFocus] + elapsed
                }));

                logEvent('focus_switch', {
                    from: activeFocus,
                    to: newFocus,
                    timeOnPreviousFocus: elapsed
                });

                setActiveFocus(newFocus);
                focusStartTimeRef.current = Date.now();
            };

            // Handle resource tab switch (for extended condition)
            const handleTabSwitch = (newTab) => {
                if (newTab === activeTab) return;
                if (tabLoading[newTab]) return; // Don't switch if already loading

                const now = Date.now();
                const timeOnPreviousTab = now - tabStartTimeRef.current;

                // Update accumulated time for previous tab
                setTabUsageTimes(prev => ({
                    ...prev,
                    [activeTab]: prev[activeTab] + timeOnPreviousTab
                }));

                logEvent('resource_tab_switch', {
                    from: activeTab,
                    to: newTab,
                    timeOnPreviousTab,
                    timestamp: now
                });

                tabStartTimeRef.current = now;

                // If first time clicking this tab, show fake loading for 2 seconds (except chat)
                if (!tabLoaded[newTab] && newTab !== 'chat') {
                    setTabLoading(prev => ({ ...prev, [newTab]: true }));
                    setActiveTab(newTab);
                    setTimeout(() => {
                        setTabLoading(prev => ({ ...prev, [newTab]: false }));
                        setTabLoaded(prev => ({ ...prev, [newTab]: true }));
                    }, 2000);
                } else {
                    setActiveTab(newTab);
                }
            };

            // Handle audio events (for extended condition)
            const handleAudioPlay = () => {
                logEvent('audio_play', {
                    currentTime: audioRef.current?.currentTime || 0,
                    timestamp: Date.now()
                });
            };

            const handleAudioPause = () => {
                logEvent('audio_pause', {
                    currentTime: audioRef.current?.currentTime || 0,
                    timestamp: Date.now()
                });
            };

            const handleAudioEnded = () => {
                logEvent('audio_ended', {
                    duration: audioRef.current?.duration || 0,
                    timestamp: Date.now()
                });
            };

            const handleAudioSeeked = () => {
                logEvent('audio_seeked', {
                    currentTime: audioRef.current?.currentTime || 0,
                    timestamp: Date.now()
                });
            };

            // Handle video events (for extended condition)
            const handleVideoPlay = () => {
                logEvent('video_play', {
                    currentTime: videoRef.current?.currentTime || 0,
                    timestamp: Date.now()
                });
            };

            const handleVideoPause = () => {
                logEvent('video_pause', {
                    currentTime: videoRef.current?.currentTime || 0,
                    timestamp: Date.now()
                });
            };

            const handleVideoEnded = () => {
                logEvent('video_ended', {
                    duration: videoRef.current?.duration || 0,
                    timestamp: Date.now()
                });
            };

            const handleVideoSeeked = () => {
                logEvent('video_seeked', {
                    currentTime: videoRef.current?.currentTime || 0,
                    timestamp: Date.now()
                });
            };

            // Handle typing in Chat
            const handleTyping = () => {
                if (activeFocus !== 'chat') return;

                const now = Date.now();

                if (!isTypingRef.current) {
                    const noneTypingDuration = now - lastTypingActivityRef.current;
                    if (noneTypingDuration > 100) {
                        logEvent('llm_activity', {
                            classification: 'none-typing',
                            duration: noneTypingDuration
                        });
                    }
                    isTypingRef.current = true;
                    lastTypingActivityRef.current = now;
                }

                if (typingTimeoutRef.current) {
                    clearTimeout(typingTimeoutRef.current);
                }

                typingTimeoutRef.current = setTimeout(() => {
                    const stopTime = Date.now();
                    const typingDuration = stopTime - lastTypingActivityRef.current;

                    logEvent('llm_activity', {
                        classification: 'typing',
                        duration: typingDuration
                    });

                    isTypingRef.current = false;
                    lastTypingActivityRef.current = stopTime;
                }, 2000);
            };

            // Handle key press in chat input
            const handleChatKeyDown = (e) => {
                handleTyping();
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (inputMessage.trim()) {
                        e.target.form.requestSubmit();
                    }
                }
            };

            // Auto-resize textarea
            const handleTextareaChange = (e) => {
                setInputMessage(e.target.value);
                e.target.style.height = 'auto';
                const lineHeight = 24;
                const maxLines = 11;
                const maxHeight = lineHeight * maxLines;
                const newHeight = Math.min(e.target.scrollHeight, maxHeight);
                e.target.style.height = newHeight + 'px';
            };

            // Handle scroll
            const handleScroll = (e) => {
                if (activeFocus !== 'reading') return;

                const scrollY = e.target.scrollTop;
                const viewportHeight = e.target.clientHeight;
                setScrollPosition(scrollY);

                const newSection = getCurrentSection(scrollY, viewportHeight);
                if (newSection !== currentSection) {
                    setCurrentSection(newSection);
                }

                const now = Date.now();

                if (!isScrollingRef.current) {
                    isScrollingRef.current = true;
                    scrollStartTimeRef.current = now;
                    sectionBeforeScrollRef.current = currentSection;

                    if (lastActivityTimeRef.current === 0) {
                        lastActivityTimeRef.current = now;
                    }
                }

                if (scrollTimeoutRef.current) {
                    clearTimeout(scrollTimeoutRef.current);
                }

                scrollTimeoutRef.current = setTimeout(() => {
                    const scrollStopTime = Date.now();
                    const scrollDuration = scrollStopTime - scrollStartTimeRef.current;
                    const pauseBeforeScroll = scrollStartTimeRef.current - lastActivityTimeRef.current;

                    let classification = pauseBeforeScroll > 5000 ? 'reading' : (pauseBeforeScroll > 2000 ? 'scanning' : 'scrolling');

                    logEvent('scroll_action', {
                        scrollY,
                        sectionBeforeScroll: sectionBeforeScrollRef.current,
                        sectionAfterScroll: newSection,
                        classification,
                        pauseDuration: pauseBeforeScroll,
                        scrollDuration,
                        timestamp: scrollStopTime
                    });

                    lastActivityTimeRef.current = scrollStopTime;
                    isScrollingRef.current = false;
                }, 200);
            };

            // Handle text selection
            const handleTextSelection = () => {
                const selection = window.getSelection();
                const text = selection.toString();
                if (text.length > 0) {
                    setSelectedText(text);
                    logEvent('text_selection', { selectedText: text });
                }
            };

            // Send LLM message
            const handleSendMessage = async (e) => {
                e.preventDefault();
                if (!inputMessage.trim()) return;

                const apiKey = '__OPENAI_API_KEY__';
                const questionTime = Date.now();

                const userMessage = {
                    role: 'user',
                    content: inputMessage,
                    timestamp: questionTime
                };

                setMessages(prev => [...prev, userMessage]);
                logEvent('llm_question_asked', { question: inputMessage, timestamp: questionTime });

                setIsLoading(true);
                const queryText = inputMessage;
                setInputMessage('');

                if (textareaRef.current) {
                    textareaRef.current.style.height = 'auto';
                }

                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [
                                {
                                    role: 'system',
                                    content: `You are an expert research assistant helping a researcher understand an academic paper.

**Paper Content:**
${paperContent.replace(/<[^>]*>/g, '')}

**Your Role:**
- Provide clear, accurate, and insightful answers based on the paper
- Use specific examples and details from the paper when relevant
- Structure your responses well (use headings, bullet points, numbering when appropriate)
- If asked to summarize, focus on key contributions, methods, and findings
- If information is not in the paper, clearly state that
- Use Korean if the user asks in Korean, English if they ask in English
- Be concise but thorough - aim for clarity over length

**Response Format:**
Use markdown formatting for better readability:
- **Bold** for key terms or important points
- Bullet points for lists
- Numbered lists for steps or sequences
- Code blocks for technical details if needed`
                                },
                                ...messages.map(msg => ({
                                    role: msg.role,
                                    content: msg.content
                                })),
                                { role: 'user', content: queryText }
                            ],
                            max_tokens: 16384,
                            temperature: 0.5
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error?.message || 'API request failed');
                    }

                    const data = await response.json();
                    const assistantResponse = data.choices[0].message.content;
                    const answerTime = Date.now();

                    const assistantMessage = {
                        role: 'assistant',
                        content: assistantResponse,
                        timestamp: answerTime
                    };

                    setMessages(prev => [...prev, assistantMessage]);

                    setChatHistory(prev => [...prev, {
                        question: queryText,
                        questionTime,
                        answer: assistantResponse,
                        answerTime,
                        responseTime: answerTime - questionTime
                    }]);

                    logEvent('llm_answer_received', {
                        question: queryText,
                        answer: assistantResponse,
                        responseTime: answerTime - questionTime,
                        timestamp: answerTime
                    });
                } catch (error) {
                    console.error('Error calling OpenAI API:', error);
                    setMessages(prev => [...prev, {
                        role: 'assistant',
                        content: `Error: ${error.message}`,
                        timestamp: Date.now()
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };

            // Markdown renderer with nested lists, tables, blockquotes, and horizontal rules
            const renderMarkdown = (text) => {
                if (!text) return '';

                let html = text;

                // Code blocks (```code```) - process first to avoid interference
                html = html.replace(/```([^`]+)```/g, '<pre style="background: #f5f5f5; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 8px 0;"><code>$1</code></pre>');

                // Inline code (`code`)
                html = html.replace(/`([^`]+)`/g, '<code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">$1</code>');

                // Bold (**text** or __text__)
                html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');

                // Italic (*text* or _text_) - be careful not to match list items
                html = html.replace(/(?<![*\-])\*([^\*\n]+)\*(?!\*)/g, '<em>$1</em>');
                html = html.replace(/(?<!_)_([^_\n]+)_(?!_)/g, '<em>$1</em>');

                // Headers (# text) - process from most specific (####) to least specific (#)
                html = html.replace(/^#### (.+)$/gm, '<h4 style="font-size: 1.1em; font-weight: 600; margin: 12px 0 6px 0;">$1</h4>');
                html = html.replace(/^### (.+)$/gm, '<h3 style="font-size: 1.2em; font-weight: 600; margin: 14px 0 8px 0;">$1</h3>');
                html = html.replace(/^## (.+)$/gm, '<h2 style="font-size: 1.35em; font-weight: 600; margin: 16px 0 10px 0;">$1</h2>');
                html = html.replace(/^# (.+)$/gm, '<h1 style="font-size: 1.5em; font-weight: 600; margin: 16px 0 10px 0;">$1</h1>');

                // Horizontal rule (---, ***, ___)
                html = html.replace(/^[-*_]{3,}$/gm, '<hr style="border: none; border-top: 1px solid #ddd; margin: 16px 0;">');

                // Process tables
                html = html.replace(/(?:^|\n)((?:\|[^\n]+\|\n)+)/g, (match, tableContent) => {
                    const rows = tableContent.trim().split('\n');
                    if (rows.length < 2) return match;

                    let tableHtml = '<table style="border-collapse: collapse; margin: 12px 0; width: 100%;">';

                    rows.forEach((row, rowIndex) => {
                        // Skip separator row (|---|---|)
                        if (row.match(/^\|[\s\-:]+\|$/)) return;

                        const cells = row.split('|').filter(cell => cell !== '');
                        const tag = rowIndex === 0 ? 'th' : 'td';
                        const bgColor = rowIndex === 0 ? 'background: #f5f5f5;' : '';

                        tableHtml += '<tr>';
                        cells.forEach(cell => {
                            tableHtml += `<${tag} style="border: 1px solid #ddd; padding: 8px; ${bgColor}">${cell.trim()}</${tag}>`;
                        });
                        tableHtml += '</tr>';
                    });

                    tableHtml += '</table>';
                    return tableHtml;
                });

                // Process lines for lists and blockquotes
                const lines = html.split('\n');
                let result = [];
                let listStack = []; // Track nested list levels: [{type: 'ul'|'ol', indent: number}]
                let inBlockquote = false;

                const getIndentLevel = (line) => {
                    const match = line.match(/^(\s*)/);
                    return match ? Math.floor(match[1].length / 2) : 0;
                };

                const closeListsToLevel = (targetLevel) => {
                    while (listStack.length > targetLevel) {
                        const list = listStack.pop();
                        result.push(list.type === 'ul' ? '</ul>' : '</ol>');
                    }
                };

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    const indent = getIndentLevel(line);
                    const trimmedLine = line.trim();

                    // Blockquote (> text)
                    const blockquoteMatch = trimmedLine.match(/^>\s*(.*)$/);
                    if (blockquoteMatch) {
                        closeListsToLevel(0);
                        if (!inBlockquote) {
                            result.push('<blockquote style="border-left: 4px solid #ddd; margin: 12px 0; padding: 8px 16px; color: #666; background: #f9f9f9;">');
                            inBlockquote = true;
                        }
                        result.push(blockquoteMatch[1] + '<br>');
                        continue;
                    } else if (inBlockquote) {
                        result.push('</blockquote>');
                        inBlockquote = false;
                    }

                    // Unordered list (- or *)
                    const unorderedMatch = trimmedLine.match(/^[\-\*]\s+(.+)$/);
                    // Ordered list (1. 2. etc)
                    const orderedMatch = trimmedLine.match(/^\d+\.\s+(.+)$/);

                    if (unorderedMatch) {
                        const targetLevel = indent + 1;

                        // Close lists that are deeper than current
                        closeListsToLevel(targetLevel);

                        // Open new list if needed
                        if (listStack.length < targetLevel || listStack[listStack.length - 1]?.type !== 'ul') {
                            if (listStack.length === targetLevel && listStack[listStack.length - 1]?.type === 'ol') {
                                result.push('</ol>');
                                listStack.pop();
                            }
                            result.push('<ul style="margin: ' + (listStack.length === 0 ? '8px' : '4px') + ' 0; padding-left: 24px; list-style-type: disc;">');
                            listStack.push({ type: 'ul', indent });
                        }
                        result.push('<li style="margin: 4px 0;">' + unorderedMatch[1] + '</li>');
                    } else if (orderedMatch) {
                        const targetLevel = indent + 1;

                        closeListsToLevel(targetLevel);

                        if (listStack.length < targetLevel || listStack[listStack.length - 1]?.type !== 'ol') {
                            if (listStack.length === targetLevel && listStack[listStack.length - 1]?.type === 'ul') {
                                result.push('</ul>');
                                listStack.pop();
                            }
                            result.push('<ol style="margin: ' + (listStack.length === 0 ? '8px' : '4px') + ' 0; padding-left: 24px; list-style-type: decimal;">');
                            listStack.push({ type: 'ol', indent });
                        }
                        result.push('<li style="margin: 4px 0;">' + orderedMatch[1] + '</li>');
                    } else {
                        // Not a list item - close all lists
                        closeListsToLevel(0);

                        if (trimmedLine === '') {
                            result.push('<br>');
                        } else if (!trimmedLine.startsWith('<')) {
                            // Regular text (not HTML tag)
                            result.push(line + '<br>');
                        } else {
                            result.push(line);
                        }
                    }
                }

                // Close any remaining open elements
                closeListsToLevel(0);
                if (inBlockquote) result.push('</blockquote>');

                html = result.join('');

                return html;
            };

            // Start experiment
            const startExperiment = async () => {
                if (!participantId || !currentPaper) {
                    alert('Please fill in all fields');
                    return;
                }

                const paper = papers.find(p => p.id === currentPaper);
                if (paper && paper.url) {
                    try {
                        const response = await fetch(paper.url);
                        const html = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const proseDiv = doc.querySelector('.prose');

                        if (proseDiv) {
                            setPaperContent(proseDiv.innerHTML);

                            // Load quiz questions
                            fetch(`questions_data/${currentPaper}.json`)
                                .then(res => res.ok ? res.json() : null)
                                .then(data => {
                                    if (data && data.questions) {
                                        setQuizQuestions(data.questions);
                                    }
                                })
                                .catch(() => {});
                        } else {
                            setPaperContent('<p>Error: Could not load paper content</p>');
                        }
                    } catch (error) {
                        console.error('Error loading paper:', error);
                        setPaperContent('<p>Error loading paper.</p>');
                    }
                }

                setPhase('reading-guide');
                logEvent('reading_guide_shown');
            };

            // Complete reading phase
            const completeReading = async () => {
                setReadingActive(false);

                const now = Date.now();
                let finalEvent = null;

                if (activeFocus === 'reading') {
                    const finalPauseDuration = now - lastActivityTimeRef.current;
                    let finalClassification = finalPauseDuration > 5000 ? 'reading' : (finalPauseDuration > 2000 ? 'scanning' : 'scrolling');

                    eventIdCounter.current++;
                    finalEvent = {
                        eventId: `${sessionId}_${eventIdCounter.current}`,
                        timestamp: now,
                        eventType: 'scroll_action',
                        phase: 'reading',
                        participantId,
                        sessionId,
                        condition,
                        paper: currentPaper,
                        scrollY: pdfContainerRef.current?.scrollTop || 0,
                        sectionBeforeScroll: currentSection,
                        sectionAfterScroll: currentSection,
                        classification: finalClassification,
                        pauseDuration: finalPauseDuration,
                        scrollDuration: 0,
                        isFinalSegment: true
                    };

                    setEvents(prev => [...prev, finalEvent]);
                }

                const elapsed = Date.now() - focusStartTimeRef.current;
                const finalFocusTimes = {
                    ...focusTimes,
                    [activeFocus]: focusTimes[activeFocus] + elapsed
                };

                const readingDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.reading = readingDuration;

                // Classification summary
                const scrollEvents = events.filter(e => e.eventType === 'scroll_action');
                const classificationSummary = {
                    reading: {
                        count: scrollEvents.filter(e => e.classification === 'reading').length,
                        totalDuration: scrollEvents.filter(e => e.classification === 'reading').reduce((sum, e) => sum + (e.pauseDuration || 0), 0)
                    },
                    scanning: {
                        count: scrollEvents.filter(e => e.classification === 'scanning').length,
                        totalDuration: scrollEvents.filter(e => e.classification === 'scanning').reduce((sum, e) => sum + (e.pauseDuration || 0), 0)
                    },
                    scrolling: {
                        count: scrollEvents.filter(e => e.classification === 'scrolling').length,
                        totalDuration: scrollEvents.filter(e => e.classification === 'scrolling').reduce((sum, e) => sum + (e.pauseDuration || 0), 0)
                    }
                };

                logEvent('reading_phase_complete', {
                    duration: readingDuration,
                    focusTimes: finalFocusTimes,
                    classificationSummary
                });

                // Save to Firebase
                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );

                        let readingEvents = events.filter(e =>
                            e.phase === 'reading' &&
                            (e.eventType === 'scroll_action' || e.eventType === 'focus_switch' ||
                             e.eventType === 'tab_switch' || e.eventType === 'llm_activity' ||
                             e.eventType === 'text_selection' || e.eventType === 'resource_tab_switch' ||
                             e.eventType === 'audio_play' || e.eventType === 'audio_pause' ||
                             e.eventType === 'audio_ended' || e.eventType === 'audio_seeked' ||
                             e.eventType === 'video_play' || e.eventType === 'video_pause' ||
                             e.eventType === 'video_ended' || e.eventType === 'video_seeked')
                        );

                        if (finalEvent) {
                            readingEvents = [...readingEvents, finalEvent];
                        }

                        const updateData = {
                            'reading.duration': readingDuration,
                            'reading.focusTimes': finalFocusTimes,
                            'reading.classificationSummary': classificationSummary,
                            'reading.events': readingEvents,
                            'reading.completedAt': window.firebaseServerTimestamp()
                        };

                        if ((condition === 'with_llm' || condition === 'with_llm_extended') && chatHistory.length > 0) {
                            updateData['llmInteraction.messages'] = chatHistory;
                            updateData['llmInteraction.totalQueries'] = chatHistory.length;
                        }

                        // Save extended condition data
                        if (condition === 'with_llm_extended') {
                            // Calculate final tab usage time
                            const finalTabTime = Date.now() - tabStartTimeRef.current;
                            const finalTabUsageTimes = {
                                ...tabUsageTimes,
                                [activeTab]: tabUsageTimes[activeTab] + finalTabTime
                            };

                            updateData['extendedResources.tabUsageTimes'] = finalTabUsageTimes;
                            updateData['extendedResources.resourcesAvailable'] = {
                                infographics: !!resourceContent.infographics,
                                video: !!resourceContent.video,
                                audio: !!resourceContent.audio,
                                simplified: !!resourceContent.simplified
                            };

                            // Count audio events
                            const audioEvents = events.filter(e =>
                                e.eventType === 'audio_play' ||
                                e.eventType === 'audio_pause' ||
                                e.eventType === 'audio_ended' ||
                                e.eventType === 'audio_seeked'
                            );
                            updateData['extendedResources.audioInteractions'] = audioEvents.length;

                            // Count video events
                            const videoEvents = events.filter(e =>
                                e.eventType === 'video_play' ||
                                e.eventType === 'video_pause' ||
                                e.eventType === 'video_ended' ||
                                e.eventType === 'video_seeked'
                            );
                            updateData['extendedResources.videoInteractions'] = videoEvents.length;

                            // Count tab switches
                            const tabSwitchEvents = events.filter(e => e.eventType === 'resource_tab_switch');
                            updateData['extendedResources.tabSwitchCount'] = tabSwitchEvents.length;

                            // Save in-tab quiz answers
                            if (Object.keys(inTabQuizAnswers).length > 0) {
                                updateData['extendedResources.inTabQuizAnswers'] = inTabQuizAnswers;
                            }
                        }

                        await window.firebaseUpdateDoc(experimentRef, updateData);
                        console.log('âœ… Reading phase data saved');
                    }
                } catch (error) {
                    console.error('âŒ Failed to save reading data:', error);
                }

                setPhase('quiz-guide');
                logEvent('quiz_guide_shown');
            };

            // Handle quiz answer
            const handleQuizAnswer = (questionId, answer) => {
                setQuizAnswers(prev => ({ ...prev, [questionId]: answer }));
                logEvent('quiz_answer', { questionId, answer });
            };

            // Complete quiz phase
            const completeQuiz = async () => {
                setQuizActive(false);
                const quizDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.quiz = quizDuration;

                // Auto-grade quiz
                let correctCount = 0;
                let notSureCount = 0;
                const totalQuestions = quizQuestions.length;
                const gradingDetails = {};

                quizQuestions.forEach(q => {
                    const userAnswer = quizAnswers[q.id];
                    const isNotSure = userAnswer === "Not Sure";
                    const isCorrect = userAnswer === q.correctAnswer;

                    if (isNotSure) notSureCount++;
                    if (isCorrect) correctCount++;

                    gradingDetails[q.id] = {
                        userAnswer: userAnswer || null,
                        correctAnswer: q.correctAnswer,
                        isCorrect: isCorrect,
                        isNotSure: isNotSure
                    };
                });

                const accuracy = totalQuestions > 0 ? (correctCount / totalQuestions * 100).toFixed(1) : 0;

                logEvent('quiz_phase_complete', {
                    answers: quizAnswers,
                    duration: quizDuration,
                    correctCount,
                    notSureCount,
                    totalQuestions,
                    accuracy
                });

                // Set redirecting flag to prevent beforeunload warning (don't change phase to avoid flash)
                setIsRedirecting(true);

                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );

                        await window.firebaseUpdateDoc(experimentRef, {
                            'quiz.answers': quizAnswers,
                            'quiz.duration': quizDuration,
                            'quiz.gradingDetails': gradingDetails,
                            'quiz.correctCount': correctCount,
                            'quiz.notSureCount': notSureCount,
                            'quiz.totalQuestions': totalQuestions,
                            'quiz.accuracy': parseFloat(accuracy),
                            'quiz.submittedAt': window.firebaseServerTimestamp()
                        });
                        console.log('âœ… Quiz data saved with grading:', { correctCount, totalQuestions, accuracy: accuracy + '%' });
                    }
                } catch (error) {
                    console.error('âŒ Failed to save quiz data:', error);
                }

                // Redirect to post-task.html
                logEvent('quiz_completed_redirecting');

                const urlParams = new URLSearchParams(window.location.search);
                const mode = urlParams.get('mode') || 'experiment';
                const params = new URLSearchParams({
                    participantId,
                    mode,
                    condition,
                    paper: currentPaper
                });
                window.location.href = `post-task.html?${params.toString()}`;
            };

            // Handle review change
            const handleReviewChange = (field, value) => {
                setReviewData(prev => ({ ...prev, [field]: value }));
            };

            // Complete review phase
            const completeReview = async () => {
                setReviewActive(false);
                const reviewDuration = Date.now() - phaseStartTime.current;
                phaseTimers.current.review = reviewDuration;
                logEvent('review_phase_complete', { reviewData, duration: reviewDuration });

                try {
                    if (window.firebaseDb && participantId && sessionId) {
                        const experimentRef = window.firebaseDoc(
                            window.firebaseDb,
                            `users/${participantId}/experiments/${sessionId}`
                        );

                        await window.firebaseUpdateDoc(experimentRef, {
                            'review.rating': reviewData.rating,
                            'review.strengths': reviewData.strengths,
                            'review.weaknesses': reviewData.weaknesses,
                            'review.suggestions': reviewData.suggestions,
                            'review.duration': reviewDuration,
                            'review.submittedAt': window.firebaseServerTimestamp(),
                            'status': 'completed',
                            'completedAt': window.firebaseServerTimestamp()
                        });
                        console.log('âœ… Experiment completed');
                    }
                } catch (error) {
                    console.error('âŒ Failed to complete experiment:', error);
                }

                setPhase('complete');
                logEvent('experiment_complete');
            };

            // Return to start
            const returnToStart = () => {
                // Reset all state
                setPhase('setup');
                setParticipantId('');
                setCondition('without_llm');
                setCurrentPaper('');
                setPaperContent('');
                setMessages([]);
                setChatHistory([]);
                setQuizAnswers({});
                setReviewData({ rating: 0, strengths: '', weaknesses: '', suggestions: '' });
                setEvents([]);
                setActiveTab(null);
                setResourceContent({ infographics: null, video: null, audio: null, audioType: null, simplified: null });
                setTabUsageTimes({ infographics: 0, video: 0, audio: 0, simplified: 0, chat: 0 });
                eventIdCounter.current = 0;
                unsavedEventsCount.current = 0;
                tabStartTimeRef.current = Date.now();
            };

            // ============ RENDER PHASES ============

            // SETUP PHASE
            if (phase === 'setup') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full">
                            <div className="text-center mb-8">
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">Reading Experiment</h1>
                            </div>

                            <div className="space-y-5">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Prolific ID *
                                    </label>
                                    <input
                                        type="text"
                                        value={participantId}
                                        onChange={(e) => setParticipantId(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                        placeholder="e.g., P001"
                                    />
                                </div>

                                <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                        Condition *
                                    </label>
                                    <select
                                        value={condition}
                                        onChange={(e) => setCondition(e.target.value)}
                                        className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    >
                                        <option value="without_llm">Without LLM (Control)</option>
                                        <option value="with_llm">With LLM</option>
                                        <option value="with_llm_extended">With LLM + Extended Resources</option>
                                    </select>
                                </div>

                                <button
                                    onClick={startExperiment}
                                    disabled={!participantId}
                                    className="w-full bg-blue-600 text-white py-3 px-6 rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed font-medium transition-colors text-lg mt-6"
                                >
                                    Start Experiment
                                </button>

                                <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                                    <p className="text-sm text-gray-700">
                                        <strong>Experiment Structure:</strong><br/>
                                        1. Reading (20 min)<br/>
                                        2. Quiz (5 min)<br/>
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            // READING GUIDE PHASE
            if (phase === 'reading-guide') {
                const paper = papers.find(p => p.id === currentPaper);
                const conditionLabels = {
                    'without_llm': 'Read the paper without AI assistant.',
                    'with_llm': 'Read the paper with AI chatbot assistance.',
                    'with_llm_extended': 'With AI Chat + Extended Resources'
                };

                return (
                    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-3xl w-full">
                            <div className="text-center mb-8">
                                <div className="text-5xl mb-4">ðŸ“–</div>
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">Paper Reading</h1>
                            </div>

                            <div className="space-y-6 mb-8">
                                <div className="bg-blue-50 border-l-4 border-blue-500 p-4">
                                    <p className="text-sm text-blue-900">
                                        <strong>Condition:</strong> {conditionLabels[condition]}
                                    </p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Title</h3>
                                    <p className="text-gray-700">{paper?.name}</p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Time Limit</h3>
                                    <p className="text-3xl font-bold text-blue-600">20min</p>
                                </div>

                                {/* AI Usage Warning for without_llm condition */}
                                {condition === 'without_llm' && (
                                    <div className="bg-red-50 border-2 border-red-300 rounded-lg p-6">
                                        <h3 className="font-bold text-lg text-red-800 mb-3">
                                            âš ï¸ You have been assigned to a condition where AI use is not allowed.
                                        </h3>
                                        <p className="text-red-700 mb-4">
                                            You must not use any AI-based tools (e.g., ChatGPT, Claude, and extensions) during this task.
                                        </p>
                                        <label className="flex items-start space-x-3 cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={noAiAgreed}
                                                onChange={(e) => setNoAiAgreed(e.target.checked)}
                                                className="w-5 h-5 mt-0.5 rounded border-red-300 text-red-600 focus:ring-red-500"
                                            />
                                            <span className="text-sm font-medium text-red-800">
                                                I understand and will not to use any AI tools during this task.
                                            </span>
                                        </label>
                                    </div>
                                )}
                            </div>

                            <button
                                onClick={() => {
                                    setPhase('reading');
                                    setReadingActive(true);
                                    phaseStartTime.current = Date.now();
                                    lastActivityTimeRef.current = Date.now();
                                    logEvent('reading_started');
                                }}
                                disabled={condition === 'without_llm' && !noAiAgreed}
                                className={`w-full px-8 py-4 rounded-lg text-lg font-medium transition-colors ${
                                    condition === 'without_llm' && !noAiAgreed
                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        : 'bg-blue-600 text-white hover:bg-blue-700'
                                }`}
                            >
                                Start â†’
                            </button>
                        </div>
                    </div>
                );
            }

            // READING PHASE
            if (phase === 'reading') {
                const showRightPanel = condition === 'with_llm' || condition === 'with_llm_extended';

                // Chat UI - inline JSX to prevent re-mount on re-render
                const chatUI = (
                    <div className="flex-1 flex flex-col overflow-hidden">
                        <div className="flex-1 overflow-y-auto bg-white">
                            {messages.length === 0 ? (
                                <div className="text-center text-gray-500" style={{marginTop: '30px'}}>
                                    <div className="text-4xl mb-4">ðŸ’¬</div>
                                    <p className="font-medium">Chat with the AI assistant</p>
                                    <p className="text-sm mt-2">Type your questions in the text field below.</p>
                                </div>
                            ) : (
                                <div className="space-y-4 p-4">
                                    {messages.map((msg, idx) => (
                                        <div key={idx} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                            <div className={`max-w-[85%] rounded-2xl px-4 py-3 ${
                                                msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-900'
                                            }`}>
                                                {msg.role === 'assistant' ? (
                                                    <div className="text-sm" dangerouslySetInnerHTML={{ __html: renderMarkdown(msg.content) }} />
                                                ) : (
                                                    <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                    {isLoading && (
                                        <div className="flex justify-start">
                                            <div className="bg-gray-100 rounded-2xl px-4 py-3">
                                                <div className="flex space-x-2">
                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce"></div>
                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '150ms'}}></div>
                                                    <div className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{animationDelay: '300ms'}}></div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    <div ref={chatMessagesEndRef} />
                                </div>
                            )}
                        </div>

                        <div className="p-4 border-t bg-white">
                            <form onSubmit={handleSendMessage} className="flex items-center space-x-2">
                                <textarea
                                    ref={textareaRef}
                                    value={inputMessage}
                                    onChange={handleTextareaChange}
                                    onKeyDown={handleChatKeyDown}
                                    placeholder="Message (Shift+Enter for newline)"
                                    className="flex-1 px-4 py-2 border border-gray-300 rounded-2xl resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                                    style={{maxHeight: '120px', minHeight: '40px'}}
                                    rows={1}
                                    disabled={isLoading}
                                />
                                <button
                                    type="submit"
                                    disabled={isLoading || !inputMessage.trim()}
                                    className="p-2 bg-blue-600 text-white rounded-full hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed"
                                >
                                    <SendIcon />
                                </button>
                            </form>
                        </div>
                    </div>
                );

                // Infographics Tab - inline JSX
                const infographicsTab = (
                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                        {resourceContent.infographics ? (
                            <img
                                src={resourceContent.infographics}
                                alt="Infographic"
                                className="max-w-full h-auto mx-auto"
                            />
                        ) : (
                            <div className="text-center text-gray-500 mt-12">
                                <div className="text-4xl mb-4">ðŸ“Š</div>
                                <p>No infographic available</p>
                            </div>
                        )}
                    </div>
                );

                // Video Tab - inline JSX
                const videoTab = (
                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                        {resourceContent.video ? (
                            <div className="flex flex-col items-center justify-center h-full">
                                <video
                                    ref={videoRef}
                                    controls
                                    className="w-full max-w-2xl rounded-lg shadow-lg"
                                    onPlay={handleVideoPlay}
                                    onPause={handleVideoPause}
                                    onEnded={handleVideoEnded}
                                    onSeeked={handleVideoSeeked}
                                >
                                    <source src={resourceContent.video} type="video/mp4" />
                                    Your browser does not support the video element.
                                </video>
                            </div>
                        ) : (
                            <div className="text-center text-gray-500 mt-12">
                                <div className="text-4xl mb-4">ðŸŽ¬</div>
                                <p>No video available</p>
                            </div>
                        )}
                    </div>
                );

                // Audio Tab - inline JSX
                const audioTab = (
                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                        {resourceContent.audio ? (
                            <div className="flex flex-col items-center justify-center h-full">
                                <div className="text-6xl mb-6">ðŸŽ§</div>
                                <audio
                                    ref={audioRef}
                                    controls
                                    className="w-full max-w-md"
                                    onPlay={handleAudioPlay}
                                    onPause={handleAudioPause}
                                    onEnded={handleAudioEnded}
                                    onSeeked={handleAudioSeeked}
                                >
                                    <source src={resourceContent.audio} type={resourceContent.audioType || 'audio/mpeg'} />
                                    Your browser does not support the audio element.
                                </audio>
                            </div>
                        ) : (
                            <div className="text-center text-gray-500 mt-12">
                                <div className="text-4xl mb-4">ðŸŽµ</div>
                                <p>No audio available</p>
                            </div>
                        )}
                    </div>
                );

                // Simplified Text Tab - inline JSX
                const simplifiedTab = (
                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                        {resourceContent.simplified ? (
                            <div
                                className="prose max-w-none bg-white p-6 rounded-lg shadow"
                                dangerouslySetInnerHTML={{ __html: resourceContent.simplified }}
                            />
                        ) : (
                            <div className="text-center text-gray-500 mt-12">
                                <div className="text-4xl mb-4">ðŸ“</div>
                                <p>No simplified text available</p>
                            </div>
                        )}
                    </div>
                );

                return (
                    <div className="h-screen flex flex-col bg-gray-100">
                        {/* Header */}
                        <div className="bg-white shadow-md px-6 py-4 flex items-center justify-between border-b-2">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">
                                    [Paper Reading] {papers.find(p => p.id === currentPaper)?.name}
                                </h2>
                                <p className="text-sm text-gray-600">
                                    {participantId} | {condition} | Section: <strong>{currentSection}</strong>
                                </p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer
                                    seconds={20 * 60}
                                    isActive={readingActive}
                                    phase="reading"
                                    onTimeUpdate={(time) => setReadingTimeLeft(time)}
                                    onComplete={() => {
                                        // Time's up - show popup and proceed
                                        setShowFinishPopup(true);
                                    }}
                                />
                                <div className="relative group">
                                    <button
                                        onClick={() => setShowFinishPopup(true)}
                                        disabled={readingTimeLeft > 0}
                                        className={`flex items-center space-x-2 px-6 py-3 rounded-lg font-medium ${
                                            readingTimeLeft > 0
                                                ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                                : 'bg-green-600 text-white hover:bg-green-700'
                                        }`}
                                    >
                                        <CheckIcon />
                                        <span>Finish Reading</span>
                                    </button>
                                    {readingTimeLeft > 0 && (
                                        <div className="absolute top-full right-0 mt-2 px-4 py-3 bg-gray-800 text-white text-sm rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-50">
                                            <div className="absolute bottom-full right-4 border-8 border-transparent border-b-gray-800"></div>
                                            <div className="font-bold mb-1">You cannot proceed during reading time.</div>
                                            <div className="text-gray-300">Please continue reading the paper for the remaining time.</div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>

                        {/* Main content */}
                        <div className="flex-1 flex overflow-hidden">
                            {/* Left Panel - Paper */}
                            <div
                                className={`${showRightPanel ? 'w-1/2' : 'flex-1'} bg-white flex flex-col overflow-hidden transition-all ${
                                    showRightPanel && activeFocus === 'reading' ? 'border-4 border-purple-500' : 'border-4 border-transparent'
                                }`}
                                onMouseEnter={() => showRightPanel && switchFocus('reading')}
                            >
                                <div
                                    ref={pdfContainerRef}
                                    onScroll={handleScroll}
                                    onMouseUp={handleTextSelection}
                                    className="flex-1 overflow-y-auto p-8"
                                >
                                    <div className="w-full max-w-[900px] mx-auto p-12">
                                        <div
                                            id="paper-content"
                                            className="prose max-w-none"
                                            dangerouslySetInnerHTML={{ __html: paperContent || '<p>Loading paper...</p>' }}
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* Right Panel - Chat / Resources */}
                            {showRightPanel && (
                                <div
                                    className={`w-1/2 bg-white flex flex-col overflow-hidden transition-all ${
                                        activeFocus === 'chat' ? 'border-4 border-purple-500' : 'border-4 border-transparent'
                                    }`}
                                    onMouseEnter={() => switchFocus('chat')}
                                >
                                    {condition === 'with_llm_extended' ? (
                                        // Extended condition with tabs
                                        <>
                                            {/* Header */}
                                            <div className="px-4 py-3 border-b bg-white">
                                                <h2 className="text-lg font-semibold text-gray-800">Gen AI Assistant</h2>
                                                <p className="text-sm text-gray-500">Feel free to explore AI-generated content to help your reading.</p>
                                            </div>

                                            {/* Tab Chips */}
                                            {(() => {
                                                const tabConfig = {
                                                    video: { icon: 'ðŸŽ¬', label: 'Video Overview', activeClass: 'bg-green-50 border-green-400 text-green-700', iconClass: 'text-green-600' },
                                                    audio: { icon: 'ðŸŽ§', label: 'Audio Overview', activeClass: 'bg-purple-50 border-purple-400 text-purple-700', iconClass: 'text-purple-600' },
                                                    infographics: { icon: 'ðŸ—ºï¸', label: 'Infographic', activeClass: 'bg-indigo-50 border-indigo-400 text-indigo-700', iconClass: 'text-indigo-600' },
                                                    simplified: { icon: 'ðŸ“', label: 'Summary Text', activeClass: 'bg-amber-50 border-amber-400 text-amber-700', iconClass: 'text-amber-600' },
                                                    quiz: { icon: 'â“', label: 'Quiz', activeClass: 'bg-rose-50 border-rose-400 text-rose-700', iconClass: 'text-rose-600' },
                                                    chat: { icon: 'ðŸ’¬', label: 'AI Chatbot', activeClass: 'bg-blue-50 border-blue-400 text-blue-700', iconClass: 'text-blue-600' }
                                                };
                                                return (
                                                    <div className="flex flex-wrap gap-2 px-4 py-3 bg-white border-b">
                                                        {tabOrder.map(tabKey => {
                                                            const tab = tabConfig[tabKey];
                                                            return (
                                                                <button
                                                                    key={tabKey}
                                                                    onClick={() => handleTabSwitch(tabKey)}
                                                                    className={`inline-flex items-center gap-2 px-4 py-2 rounded-full border text-sm font-medium transition-colors ${
                                                                        activeTab === tabKey
                                                                            ? tab.activeClass
                                                                            : 'bg-white border-gray-300 text-gray-700 hover:bg-gray-50'
                                                                    }`}
                                                                >
                                                                    <span className={tab.iconClass}>{tab.icon}</span> {tab.label}
                                                                </button>
                                                            );
                                                        })}
                                                    </div>
                                                );
                                            })()}

                                            {/* Tab Content */}
                                            <div className="flex-1 flex flex-col overflow-hidden">
                                                {activeTab === null && (
                                                    <div className="flex-1 flex flex-col bg-gray-50">
                                                        <div className="text-center text-gray-500 mt-8">
                                                            <div className="text-4xl mb-4">ðŸ‘†</div>
                                                            <p className="font-medium">Select a tab above to explore AI-generated content.</p>
                                                        </div>
                                                    </div>
                                                )}
                                                {activeTab !== null && tabLoading[activeTab] && (
                                                    <div className="flex-1 flex flex-col items-center justify-center bg-gray-50 relative overflow-hidden">
                                                        {/* Sparkles */}
                                                        <div className="absolute inset-0 pointer-events-none">
                                                            {[...Array(12)].map((_, i) => (
                                                                <div
                                                                    key={i}
                                                                    className="absolute text-purple-400"
                                                                    style={{
                                                                        left: `${10 + Math.random() * 80}%`,
                                                                        top: `${10 + Math.random() * 80}%`,
                                                                        animation: `sparkle ${1 + Math.random() * 1}s ease-in-out infinite`,
                                                                        animationDelay: `${Math.random() * 2}s`,
                                                                        fontSize: `${10 + Math.random() * 14}px`
                                                                    }}
                                                                >
                                                                    âœ¦
                                                                </div>
                                                            ))}
                                                        </div>
                                                        <div className="w-64 p-4 z-10">
                                                            <p className="text-gray-600 font-medium text-sm mb-3 text-center">âœ¨ Generating content...</p>
                                                            <div className="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                                                                <div className="bg-purple-500 h-2 rounded-full" style={{animation: 'loading 1.5s ease-in-out infinite'}}></div>
                                                            </div>
                                                        </div>
                                                        <style>{`
                                                            @keyframes loading {
                                                                0% { width: 20%; }
                                                                50% { width: 80%; }
                                                                100% { width: 20%; }
                                                            }
                                                            @keyframes sparkle {
                                                                0%, 100% { opacity: 0; transform: scale(0) rotate(0deg); }
                                                                50% { opacity: 1; transform: scale(1) rotate(180deg); }
                                                            }
                                                        `}</style>
                                                    </div>
                                                )}
                                                {activeTab === 'infographics' && !tabLoading['infographics'] && infographicsTab}
                                                {activeTab === 'video' && !tabLoading['video'] && videoTab}
                                                {activeTab === 'audio' && !tabLoading['audio'] && audioTab}
                                                {activeTab === 'simplified' && !tabLoading['simplified'] && simplifiedTab}
                                                {activeTab === 'quiz' && !tabLoading['quiz'] && (
                                                    <div className="flex-1 overflow-y-auto p-4 bg-gray-50">
                                                        <div className="max-w-2xl mx-auto">
                                                            <div className="mb-6">
                                                                <h3 className="text-lg font-semibold text-gray-800 mb-2">Quick Comprehension Check</h3>
                                                                <p className="text-sm text-gray-600">Test your understanding of the article with these questions.</p>
                                                            </div>
                                                            <div className="space-y-6">
                                                                {inTabQuizQuestions.map((q, idx) => {
                                                                    const userAnswer = inTabQuizAnswers[q.id];
                                                                    const isAnswered = !!userAnswer;
                                                                    const isCorrect = userAnswer === q.correctAnswer;
                                                                    return (
                                                                    <div key={q.id} className={`bg-white rounded-lg border p-4 ${
                                                                        isAnswered ? (isCorrect ? 'border-green-400' : 'border-red-400') : 'border-gray-200'
                                                                    }`}>
                                                                        <p className="font-medium text-gray-800 mb-3">
                                                                            {idx + 1}. {q.question}
                                                                        </p>
                                                                        <div className="space-y-2">
                                                                            {q.options.map((option, optIdx) => {
                                                                                const isSelected = userAnswer === option;
                                                                                const isCorrectOption = option === q.correctAnswer;
                                                                                let optionClass = 'border-gray-200 hover:bg-gray-50';
                                                                                if (isAnswered) {
                                                                                    if (isCorrectOption) {
                                                                                        optionClass = 'border-green-400 bg-green-50';
                                                                                    } else if (isSelected && !isCorrect) {
                                                                                        optionClass = 'border-red-400 bg-red-50';
                                                                                    }
                                                                                } else if (isSelected) {
                                                                                    optionClass = 'border-rose-400 bg-rose-50';
                                                                                }
                                                                                return (
                                                                                <label
                                                                                    key={optIdx}
                                                                                    className={`flex items-center p-3 rounded-lg border transition-colors ${optionClass} ${isAnswered ? 'cursor-default' : 'cursor-pointer'}`}
                                                                                >
                                                                                    <input
                                                                                        type="radio"
                                                                                        name={q.id}
                                                                                        value={option}
                                                                                        checked={isSelected}
                                                                                        disabled={isAnswered}
                                                                                        onChange={() => {
                                                                                            setInTabQuizAnswers(prev => ({ ...prev, [q.id]: option }));
                                                                                            logEvent('in_tab_quiz_answer', {
                                                                                                questionId: q.id,
                                                                                                answer: option,
                                                                                                isCorrect: option === q.correctAnswer
                                                                                            });
                                                                                        }}
                                                                                        className="w-4 h-4 text-rose-600 mr-3"
                                                                                    />
                                                                                    <span className={`text-sm ${isAnswered && isCorrectOption ? 'text-green-700 font-medium' : 'text-gray-700'}`}>{option}</span>
                                                                                    {isAnswered && isCorrectOption && <span className="ml-2 text-green-600">âœ“</span>}
                                                                                    {isAnswered && isSelected && !isCorrect && <span className="ml-2 text-red-600">âœ—</span>}
                                                                                </label>
                                                                            );})}
                                                                        </div>
                                                                        {isAnswered && (
                                                                            <div className={`mt-3 p-2 rounded text-sm ${isCorrect ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                                                                                {isCorrect ? 'âœ“ Correct!' : 'âœ— Incorrect. The correct answer is highlighted above.'}
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                );})}
                                                            </div>
                                                        </div>
                                                    </div>
                                                )}
                                                {activeTab === 'chat' && !tabLoading['chat'] && chatUI}
                                            </div>
                                        </>
                                    ) : (
                                        // Standard with_llm condition - just chat
                                        <>
                                            <div className="px-4 py-3 border-b bg-white flex items-center justify-between">
                                                <span className="text-xl font-semibold">AI Assistant</span>
                                            </div>
                                            {chatUI}
                                        </>
                                    )}
                                </div>
                            )}
                        </div>

                        {/* Finish Popup */}
                        {showFinishPopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">Do you want to finish reading session?</h3>
                                    <p className="text-gray-600 mb-6">Continue to next step</p>
                                    <div className="flex space-x-4">
                                        <button
                                            onClick={() => setShowFinishPopup(false)}
                                            className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowFinishPopup(false);
                                                if (condition === 'without_llm') {
                                                    setShowAiUsagePopup(true);
                                                } else {
                                                    completeReading();
                                                }
                                            }}
                                            className="flex-1 px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
                                        >
                                            Confirm
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* AI Usage Check Popup (for without_llm condition) */}
                        {showAiUsagePopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">Did you use any external AI tools while reading the paper?</h3>
                                    <p className="text-gray-600 mb-6">Even if you did, it will not affect your compensation. Please answer honestly.</p>

                                    <div className="space-y-3 mb-6">
                                        <label className="flex items-center space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                                            <input
                                                type="radio"
                                                name="aiUsage"
                                                value="yes"
                                                checked={usedAiDuringReading === 'yes'}
                                                onChange={() => setUsedAiDuringReading('yes')}
                                                className="w-5 h-5"
                                            />
                                            <span className="text-gray-700">Yes, I used AI tools.</span>
                                        </label>
                                        <label className="flex items-center space-x-3 p-3 border border-gray-200 rounded-lg hover:bg-gray-50 cursor-pointer">
                                            <input
                                                type="radio"
                                                name="aiUsage"
                                                value="no"
                                                checked={usedAiDuringReading === 'no'}
                                                onChange={() => setUsedAiDuringReading('no')}
                                                className="w-5 h-5"
                                            />
                                            <span className="text-gray-700">No, I did not use AI tools.</span>
                                        </label>
                                    </div>

                                    <button
                                        onClick={async () => {
                                            if (usedAiDuringReading) {
                                                // Save AI usage directly to Firebase
                                                try {
                                                    const userRef = window.firebaseDoc(window.firebaseDb, 'users', participantId);
                                                    await window.firebaseSetDoc(userRef, {
                                                        aiUsageDuringReading: usedAiDuringReading,
                                                        aiUsageReportedAt: new Date().toISOString()
                                                    }, { merge: true });
                                                    console.log('AI usage saved:', usedAiDuringReading);
                                                } catch (error) {
                                                    console.error('Error saving AI usage:', error);
                                                }
                                                logEvent('ai_usage_reported', { usedAi: usedAiDuringReading });
                                                setShowAiUsagePopup(false);
                                                completeReading();
                                            }
                                        }}
                                        disabled={!usedAiDuringReading}
                                        className={`w-full px-4 py-3 rounded-lg font-medium ${
                                            usedAiDuringReading
                                                ? 'bg-blue-600 text-white hover:bg-blue-700'
                                                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        }`}
                                    >
                                        Next â†’
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // QUIZ GUIDE PHASE
            if (phase === 'quiz-guide') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-3xl w-full">
                            <div className="text-center mb-8">
                                <div className="text-5xl mb-4">ðŸ“</div>
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">Comprehension Quiz</h1>
                            </div>

                            <div className="space-y-6 mb-8">
                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Guide</h3>
                                    <ul>
                                        <li>
                                    <p className="text-gray-700">Answer the questions based on your understanding of the paper.</p>
                                    </li>
                                    <li>
                                     <p className="text-gray-700">If you're unsure, please select "Not Sure" instead of guessing.</p>   
                                    </li>
                                    </ul>
                                    </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Time Limit</h3>
                                    <p className="text-3xl font-bold text-purple-600">5min</p>
                                </div>
                            </div>

                            <button
                                onClick={() => {
                                    setPhase('quiz');
                                    setQuizActive(true);
                                    phaseStartTime.current = Date.now();
                                    logEvent('quiz_phase_start');
                                }}
                                className="w-full px-8 py-4 bg-purple-600 text-white rounded-lg hover:bg-purple-700 text-lg font-medium"
                            >
                                Start â†’
                            </button>
                        </div>
                    </div>
                );
            }

            // QUIZ PHASE
            if (phase === 'quiz') {
                return (
                    <div className="min-h-screen bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between sticky top-0 z-50">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Comprehension Quiz</h2>
                                <p className="text-sm text-gray-600">Closed-book</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer
                                    seconds={5 * 60}
                                    isActive={quizActive}
                                    phase="quiz"
                                    onComplete={() => alert('Quiz time is up!')}
                                />
                                <button
                                    onClick={() => setShowFinishPopup(true)}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Quiz
                                </button>
                            </div>
                        </div>

                        <div className="max-w-4xl mx-auto p-8">
                            <div className="space-y-6">
                                {quizQuestions.map((q, idx) => (
                                    <div key={q.id} className="bg-white rounded-lg shadow-md p-6">
                                        <div className="flex items-start space-x-3 mb-4">
                                            <span className="flex-shrink-0 w-8 h-8 bg-blue-600 text-white rounded-full flex items-center justify-center font-bold">
                                                {idx + 1}
                                            </span>
                                            <div className="flex-1">
                                                <p className="font-medium text-gray-900 mb-2">{q.question}</p>

                                                {q.type === 'multiple_choice' ? (
                                                    <div className="space-y-2 mt-4">
                                                        {q.options?.map((option, optIdx) => (
                                                            <label key={optIdx} className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer border border-gray-200">
                                                                <input
                                                                    type="radio"
                                                                    name={`question-${q.id}`}
                                                                    value={option}
                                                                    checked={quizAnswers[q.id] === option}
                                                                    onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                                    className="w-4 h-4"
                                                                />
                                                                <span className="text-gray-700">{option}</span>
                                                            </label>
                                                        ))}
                                                        {/* Not Sure option */}
                                                        <p className="text-xs text-gray-500 mt-4 mb-2">If you're not sure, please select 'Not Sure' below.</p>
                                                        <label className="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-100 cursor-pointer border border-dashed border-gray-400 bg-gray-50">
                                                            <input
                                                                type="radio"
                                                                name={`question-${q.id}`}
                                                                value="Not Sure"
                                                                checked={quizAnswers[q.id] === "Not Sure"}
                                                                onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                                className="w-4 h-4"
                                                            />
                                                            <span className="text-gray-500 italic">Not Sure</span>
                                                        </label>
                                                    </div>
                                                ) : (
                                                    <textarea
                                                        className="w-full mt-4 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"
                                                        rows="4"
                                                        placeholder="Enter your answer..."
                                                        value={quizAnswers[q.id] || ''}
                                                        onChange={(e) => handleQuizAnswer(q.id, e.target.value)}
                                                    />
                                                )}
                                            </div>
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <div className="mt-8 p-4 bg-gray-100 rounded-lg">
                                <p className="text-sm text-gray-600">
                                    Progress: {Object.keys(quizAnswers).length} / {quizQuestions.length} questions answered
                                </p>
                            </div>
                        </div>

                        {/* Finish Quiz Popup */}
                        {showFinishPopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">End quiz session?</h3>
                                    <div className="flex space-x-4">
                                        <button
                                            onClick={() => setShowFinishPopup(false)}
                                            className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowFinishPopup(false);
                                                completeQuiz();
                                            }}
                                            className="flex-1 px-4 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 font-medium"
                                        >
                                            Confirm
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // REVIEW GUIDE PHASE
            if (phase === 'review-guide') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-50 to-teal-100 flex items-center justify-center p-4">
                        <div className="bg-white rounded-2xl shadow-2xl p-12 max-w-3xl w-full">
                            <div className="text-center mb-8">
                                <div className="text-5xl mb-4">âœï¸</div>
                                <h1 className="text-3xl font-bold text-gray-800 mb-2">Post-reading Task</h1>
                            </div>

                            <div className="space-y-6 mb-8">
                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Guidance</h3>
                                    <p className="text-gray-700">--</p>
                                </div>

                                <div className="bg-gray-50 rounded-lg p-6">
                                    <h3 className="font-bold text-lg text-gray-800 mb-2">Time Limit</h3>
                                    <p className="text-3xl font-bold text-green-600">20min</p>
                                </div>
                            </div>

                            <button
                                onClick={() => {
                                    setPhase('review');
                                    setReviewActive(true);
                                    phaseStartTime.current = Date.now();
                                    logEvent('review_phase_start');
                                }}
                                className="w-full px-8 py-4 bg-green-600 text-white rounded-lg hover:bg-green-700 text-lg font-medium"
                            >
                                Start â†’
                            </button>
                        </div>
                    </div>
                );
            }

            // REVIEW PHASE
            if (phase === 'review') {
                return (
                    <div className="h-screen flex flex-col bg-gray-50">
                        <div className="bg-white shadow-md px-6 py-4 border-b-2 flex items-center justify-between flex-shrink-0">
                            <div>
                                <h2 className="text-lg font-bold text-gray-800">Post-reading Task</h2>
                                <p className="text-sm text-gray-600">Open-book</p>
                            </div>
                            <div className="flex items-center space-x-4">
                                <Timer
                                    seconds={20 * 60}
                                    isActive={reviewActive}
                                    phase="review"
                                    onComplete={() => alert('Review time is up!')}
                                />
                                <button
                                    onClick={() => setShowFinishPopup(true)}
                                    className="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                >
                                    Submit Review
                                </button>
                            </div>
                        </div>

                        <div className="flex-1 overflow-hidden px-4 py-6">
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 h-full">
                                {/* Paper */}
                                <div className="bg-white rounded-lg shadow-md p-6 overflow-y-auto">
                                    <div className="prose max-w-none" dangerouslySetInnerHTML={{ __html: paperContent }} />
                                </div>

                                {/* Review Form */}
                                <div className="overflow-y-auto space-y-6">
                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-xl font-bold mb-4">Rating</h3>
                                        <div className="flex items-center space-x-4">
                                            {[1, 2, 3, 4, 5].map(rating => (
                                                <button
                                                    key={rating}
                                                    onClick={() => handleReviewChange('rating', rating)}
                                                    className={`w-12 h-12 rounded-full font-bold transition-colors ${
                                                        reviewData.rating === rating
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                                    }`}
                                                >
                                                    {rating}
                                                </button>
                                            ))}
                                        </div>
                                        <p className="text-xs text-gray-600 mt-2">1=Reject, 5=Accept</p>
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-2">Strengths</h3>
                                        <textarea
                                            value={reviewData.strengths}
                                            onChange={(e) => handleReviewChange('strengths', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="Strengths of this research..."
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-2">Weaknesses</h3>
                                        <textarea
                                            value={reviewData.weaknesses}
                                            onChange={(e) => handleReviewChange('weaknesses', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="Weaknesses of this research..."
                                        />
                                    </div>

                                    <div className="bg-white rounded-lg shadow-md p-6">
                                        <h3 className="text-lg font-bold mb-2">Suggestions</h3>
                                        <textarea
                                            value={reviewData.suggestions}
                                            onChange={(e) => handleReviewChange('suggestions', e.target.value)}
                                            className="w-full h-32 px-4 py-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="Suggestions for improvement..."
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Finish Review Popup */}
                        {showFinishPopup && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                                <div className="bg-white rounded-xl shadow-2xl p-8 max-w-md w-full mx-4">
                                    <h3 className="text-2xl font-bold text-gray-800 mb-4">End review session?</h3>
                                    <div className="flex space-x-4">
                                        <button
                                            onClick={() => setShowFinishPopup(false)}
                                            className="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 font-medium"
                                        >
                                            Cancel
                                        </button>
                                        <button
                                            onClick={() => {
                                                setShowFinishPopup(false);
                                                completeReview();
                                            }}
                                            className="flex-1 px-4 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-medium"
                                        >
                                            Confirm
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // COMPLETE PHASE
            if (phase === 'complete') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-green-50 to-blue-50 flex items-center justify-center p-4">
                        <div className="bg-white rounded-xl shadow-2xl p-12 max-w-2xl w-full text-center">
                            <div className="text-6xl mb-6">ðŸŽ‰</div>
                            <h1 className="text-4xl font-bold text-gray-800 mb-4">Experiment Complete!</h1>
                            <p className="text-gray-600 mb-8">Thank you for participation.</p>

                            <div className="bg-gray-50 rounded-lg p-6 mb-8 text-left">
                                <h3 className="font-bold text-lg mb-4">Summary</h3>
                                <div className="space-y-2 text-gray-700">
                                    <p>â€¢ Participant: <strong>{participantId}</strong></p>
                                    <p>â€¢ Condition: <strong>{condition}</strong></p>
                                    <p>â€¢ Paper: <strong>{papers.find(p => p.id === currentPaper)?.name}</strong></p>
                                    <p>â€¢ Quiz responses: <strong>{Object.keys(quizAnswers).length} / {quizQuestions.length}</strong></p>
                                    <p>â€¢ Review rating: <strong>{reviewData.rating} / 5</strong></p>
                                </div>
                            </div>

                            <button
                                onClick={returnToStart}
                                className="px-8 py-4 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-lg font-medium"
                            >
                                Return to Start
                            </button>
                        </div>
                    </div>
                );
            }

            return null;
        }

        ReactDOM.render(<ReadingExperimentAOM />, document.getElementById('root'));
    </script>

    <!-- Feedback Widget -->
    <script src="feedback-widget.js"></script>
</body>
</html>
